#*
This template is used to generate pyx files for the ACP245 protocol bindings.
The pyx files are the one that define the extension classes that python
code will use to create ACP245 pdus.

The lines marked with \# are comments that will be included on the generated
files, but are also useful comments to see what the template is doing on
each section.

Functions prefixed with 'util.' are defined in genacp.py Utils class.

For historical reasons, there's a field called 'present' of the generated
classes that represents if the element has data or has length 0. It should
have been called 'empty', since NOT_PRESENT in ACP245 means the element is
directly not included (truncated), and not that is included with length 0.
*#

\# Import the constants defined in c_pdu to the python world.
cimport c_pdu_gen as c_pdu
\# Enums
#for enum in $proto.enums
\# Values for enum '$enum.name'
    #for val in $enum.values
$val = c_pdu.$val
    #end for
#end for
\# Constants
#for val, type in $proto.constants
#if type == int
$val = c_pdu.$val
#else
$val = <char*>c_pdu.$val
#end if
#end for
#*
Generates the field declaration of messages and elements.

@param item the message or element that has the fields.
*#
#def declare_fields(item)
    #for fld in $item.fields
        #if fld.toggles
    cdef public object _${fld.name}
        #elif $util.is_element(fld.type)
    cdef public object ${fld.name}
        #else
    cdef public ${util.get_cython_type(fld.type)} ${fld.name}
        #end if
    #end for
#end def
#*
Generates the content of the constructor of messages and elements. It only
initializes each of the message/element fields.

@param item the message or element that is being constructed.
*#
#def gen_constructor(item)
    #for fld in $item.fields
        ${util.get_initializer(fld)}
    #end for
#end def
#*
This creates an access to a field using getattr(self, 'name') instead of
self.name.

We use this is because self.name would generate a static accessor
in Cython that would always access the generated struct field. However,
using getattr we have the possibility to extend the extension class
generated by Cython, and override 'name', so that getattr(self, 'name')
gets the overriden 'name' and not the static struct field.
Every time we access a field of the generated classes, we will use getattr
instead of direct access. This has a large impact on performance, but
also makes our generated code more flexible.
If performance is critical, we should define which fields will be extended
and which won't, so we can define when we need to use getattr and when we
should use direct struct field access.

@param name the name of the field to access.
*#
#def self_attr(name) #getattr(self,'$name')#end def
#*
Generate the mapping from Python object to the C struct fields,
to write a message object to a message struct.

@param item the element/message that will be mapped.
@param svar the variable that points to the C struct to fill.
*#
#def gen_fields_to_c(item, svar)
#for fld in $item.fields
    ## The present field of an element is handled by the parent element,
    ## as seen below, not by the element itself, so we skip it.
    #if fld.name == 'present' and $util.has_present(item)
    #continue
    #end if
    #if $util.is_any(fld.type)
        ## Is an IEAny element, set the struct values and it's present field.
        if $self_attr(fld.name) is not None:
            to_acp_ie_any(&${svar}.$fld.name, $self_attr(fld.name))
            #if $item.get_optional_fields_after(fld) and not $item.has_required_fields_after(fld)
        elif ${' or '.join(['self.%s is not None' % f.name for f in item.get_optional_fields_after(fld)])}:
            ${svar}.${fld.name}.present = 1
            #end if
        else:
            #if item.has_required_fields_after(fld)
            ${svar}.${fld.name}.present = 1
            #else
            ${svar}.${fld.name}.present = 0
            #end if
    #elif $util.is_element(fld.type)
        ## It's an ACP245 IE element. Use the generated element ._to_struct
        ## method to map the element to the struct.
        if $self_attr(fld.name) is not None:
            ## Elements that toggle a message flag (ie. the grace time element), are stored
            ## on a field called _<field_name>, so a <field_name> property can be generated
            ## that toggles the flag automatically when this property is set.
            #if $fld.toggles
            (<__c__${util.get_cython_type(fld.type)}>$self_attr('_%s' % fld.name))._to_struct(&${svar}.$fld.name)
            #else
            (<__c__${util.get_cython_type(fld.type)}>$self_attr(fld.name))._to_struct(&${svar}.$fld.name)
            #end if

        ## If the element has a present flag and the element is None, set the flag.
        #if $util.has_present(fld.type)
            ## If element has optional fields after it, and no required fields
            ## after it, generate an expression that checks that if there's
            ## an optional element which is not None, then the element is EMPTY.
            ## Othewise, if it has required field after it is also EMPTY, or
            ## otherwise it's NOT_PRESENT (element will be truncated).
            #if $item.get_optional_fields_after(fld) and not $item.has_required_fields_after(fld)
        elif ${' or '.join(['self.%s is not None' % f.name for f in item.get_optional_fields_after(fld)])}:
            ${svar}.${fld.name}.present = c_pdu.ACP_EL_EMPTY
            #end if
        else:
            #if item.has_required_fields_after(fld)
            ${svar}.${fld.name}.present = c_pdu.ACP_EL_EMPTY
            #else
            ${svar}.${fld.name}.present = c_pdu.ACP_EL_NOT_PRESENT
            #end if
        #end if
    #elif $util.is_primitive(fld.type) and $fld.toggles
        if self.${fld.name} is not None:
            $util.get_to_c_conversor(fld.type, svar + '.' + fld.name, $self_attr(fld.name))
    #else
        ## It's a primitive type, get the type conversor and set it.
        $util.get_to_c_conversor(fld.type, svar + '.' + fld.name, $self_attr(fld.name))
    #end if
#end for
#for fld in $item.get_toggle_fields
#* FIXME, handle non element toggable fields *#
#if $util.is_element(fld.type)
        ## Set the toggle flags (should also been set by property accessor, this
        ## is just to make sure, maybe can be removed?).
        if self.$fld.name is not None:
        #if fld.toggles.field.toggles
            if ${svar}.${fld.toggles.field} is None:
                ${svar}.${fld.toggles.field} = 0
        #end if
            ${svar}.${fld.toggles.field} |= ${fld.toggles.flag}
        else:
        #if fld.toggles.field.toggles
            if ${svar}.${fld.toggles.field} is not None:
                ${svar}.${fld.toggles.field} &= ~${fld.toggles.flag}
        #else
            ${svar}.${fld.toggles.field} &= ~${fld.toggles.flag}
        #end if
#end if
#end for
#end def
#*
Generate element/message property setters and getters.
These are used when the element/field toggles a message flag, so
the flag is toggled automatically when the field is set on python.

@param item the element/message that contains the fields.
*#
#def gen_field_properties(item)
#for fld in $item.fields
    #if fld.toggles
    property $fld.name:
        def __get__(self):
            return self._$fld.name
        def __set__(self, object value):
            self._$fld.name = value
            if value is not None:
        #if fld.toggles.field.toggles
                \# toggles ${fld.toggles.field.name}, so it may be None
                if self.${fld.toggles.field} is None:
                    self.${fld.toggles.field} = 0
        #end if
                self.${fld.toggles.field} |= c_pdu.${fld.toggles.flag}
            else:
        #if fld.toggles.field.toggles
                if self.${fld.toggles.field} is not None:
                    self.${fld.toggles.field} &= ~c_pdu.${fld.toggles.flag}
        #else
                self.${fld.toggles.field} &= ~c_pdu.${fld.toggles.flag}
        #end if
    #end if

#end for
#end def
#*
Generate the mapping from C struct fields to python values.

@param item the element/message that will be mapped.
@param svar the variable that points to the C struct ro read.
*#
#def gen_fields_from_c(item, svar)
#for fld in $item.fields
    ## Present field is handled by the <element>_to_py function, so skip it.
    #if fld.name == 'present' and $util.has_present(item)
    #continue
    #end if
    #if fld.toggles
    if ${svar}.${fld.toggles.field} & ${fld.toggles.flag}:
        #if $util.is_element(fld.type)
        ${fld.name} = ${fld.type.name}_to_py(&${svar}.${fld.name})
        #else
        ${fld.name} = ${util.get_to_py_conversor(fld.type, svar + '.' + fld.name)}
        #end if
    else:
        ${fld.name} = None
    #else
        #if $util.is_element(fld.type)
    ${fld.name} = ${fld.type.name}_to_py(&${svar}.${fld.name})
        #else
    ${fld.name} = ${util.get_to_py_conversor(fld.type, svar + '.' + fld.name)}
        #end if
    #end if
#end for

#end def
#*
Element Definition.
*#

#for el in $proto.elements
## Class is generated with prefix __c__, to distinguish it from the actual Python
## class that will be used and that allows type redefinition (see pdu.py).
cdef class __c__${util.to_cython_name(el)}(Element):

$declare_fields(el)
    ## Create the constructor, setting fields as optionals with default values.
    def __init__(self,
            #for fld in $el.fields
                #if fld.name == 'present' and $util.has_present(el)
            $util.get_cython_type(fld.type) $fld.name=1,
                #elif $fld.toggles and $util.is_primitive(fld.type)
            object $fld.name=None,
                #elif $util.is_element(fld.type)
            object $fld.name=None,
                #else
            $util.get_cython_type(fld.type) $fld.name=$util.get_default_value(fld),
                #end if
            #end for
            ):
        Element.__init__(self)
## Generate constructor initializators
$gen_constructor(el)
## Generate field property accessors for togglable fields.
$gen_field_properties(el)
## Generate Python to C struct function.
    cdef void _to_struct(self, c_pdu.${el.name} *el) except *:
        #if $el.has_present()
        if not self.present:
            el.present = c_pdu.ACP_EL_EMPTY
            return
        el.present = c_pdu.ACP_EL_PRESENT
        #end if
$gen_fields_to_c(el, 'el')

    def get_fields(self):
        """Returns the field names according to the protocol field order."""
        return ${','.join(["u'%s'" % x.name for x in $el.fields])},

## Generate C struct to Python object function.
cdef object ${el.name}_to_py(c_pdu.${el.name} *el):
    #if $el.has_present()
    if el.present == c_pdu.ACP_EL_NOT_PRESENT:
        return None
    #end if
$gen_fields_from_c(el, 'el')

    return ${util.to_cython_name(el)}(
    #if $el.has_present()
        present=(el.present==c_pdu.ACP_EL_PRESENT),
    #end if
    #for fld in $el.fields
        #if fld.name == 'present' and $el.has_present()
        #continue
        #end if
        ${fld.name}=${fld.name},
    #end for
    )

#*
Generate the Python Message class, which extends from the Cython extension
class.

Since it's not an extension class but an actual python class, Cython will not
make static references to the class when it's used, but will instead use
standard Python name resolution. This allows us to later change the class used
for a given element or message, replacing it with a new one and the code will
keep working without issues. To see how this is used see 'pdu.py'.
*#
class ${util.to_cython_name(el)}(__c__${util.to_cython_name(el)}):
    pass

#end for

#* Message Definition *#
#for msg in $proto.messages
cdef class ${util.to_cython_name(msg)}(Message):
    app_id = c_pdu.$util.to_c_app_id_constant(msg)
    type = c_pdu.$util.to_c_msg_type_id_constant(msg)

$declare_fields(msg)

    def __init__(self,
            Header header=None,
            #for fld in $msg.fields
                #if $fld.toggles and $util.is_primitive(fld.type)
            object $fld.name=None,
                #elif $util.is_element(fld.type)
            object $fld.name=None,
                #else
            $util.get_cython_type(fld.type) $fld.name=$util.get_default_value(fld),
                #end if
            #end for
            ):
        Message.__init__(self, header)
$gen_constructor(msg)

$gen_field_properties(msg)

    cdef void _to_struct(self, acp_msg *msg) except *:
        cdef c_pdu.$msg.name *b
        b = &msg.data.$msg.name[len('acp_msg_'):]
$gen_fields_to_c(msg, 'b')

    def get_fields(self):
        """Returns the field names according to the protocol field order."""
        return ${','.join(["u'%s'" % x.name for x in $msg.fields])},

cdef $util.to_cython_name(msg) ${msg.name}_to_py(Header header, c_pdu.${msg.name} *b):
$gen_fields_from_c(msg, 'b')
    return ${util.to_cython_name(msg)}(
        header=header,
        #for fld in $msg.fields
        ${fld.name}=${fld.name},
        #end for
    )
#end for
